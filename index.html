<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Galaga - Clon Arcade</title>
    <!-- Carga de Tailwind CSS para estilizado -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Estilos personalizados para el ambiente retro */
        body {
            background-color: #0d1117; /* Fondo oscuro casi negro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Press Start 2P', cursive;
        }

        #game-container {
            border: 4px solid #00ff00; /* Borde verde brillante */
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
            background-color: #1a1a2e; /* Fondo del juego ligeramente diferente */
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #000000;
            display: block;
        }

        .text-retro {
            color: #00ff00; /* Texto verde brillante */
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            line-height: 1.2;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="game-container" class="w-full max-w-lg aspect-[3/4]">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // === CONFIGURACIÓN GLOBAL ===
        const CANVAS_WIDTH = 400;
        const CANVAS_HEIGHT = 600;
        const PLAYER_SIZE = 20;
        const ENEMY_SIZE = 16;
        const BOSS_SIZE = 32;
        const PROJECTILE_WIDTH = 3;
        const PROJECTILE_HEIGHT = 8;
        const ENEMY_SPAWN_RATE = 200; // Tiempo entre aparición de formaciones
        const INITIAL_LIVES = 3;
        const FORMATION_GROUP_SIZE = 3; // Cuántos enemigos por grupo

        // === INICIALIZACIÓN ===
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Ajustar el canvas al contenedor
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Variables de estado del juego
        let gameFrame = 0;
        let score = 0;
        let lives = INITIAL_LIVES;
        let isGameOver = true;
        let player = null;
        let formations = []; // Array para las formaciones de enemigos
        let miniBoss = null; // Nuevo estado para el minijefe
        let powerUps = []; 
        let playerProjectiles = [];
        let enemyProjectiles = [];
        let mouseX = CANVAS_WIDTH / 2;
        let mouseY = CANVAS_HEIGHT / 2; // Permitir movimiento libre
        let gameLoopId;

        // Función de utilidad para obtener un número aleatorio entre min y max (inclusive)
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // === CLASES DE ENTIDADES ===

        // Clase Base para Proyectiles
        class Projectile {
            constructor(x, y, vx, vy, color, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.width = PROJECTILE_WIDTH;
                this.height = PROJECTILE_HEIGHT;
                this.color = color;
                this.isPlayer = isPlayer;
                this.readyToDie = false;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                // Marcar para eliminación si está fuera de pantalla
                if (this.y < -this.height || this.y > CANVAS_HEIGHT + this.height || this.x < 0 || this.x > CANVAS_WIDTH) {
                    this.readyToDie = true;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            }
        }

        // Clase Nave del Jugador
        class Player {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT - 50;
                this.width = PLAYER_SIZE;
                this.height = PLAYER_SIZE;
                this.baseSpeed = 4;
                this.currentSpeed = this.baseSpeed;
                this.baseFireRate = 20; // NO se usa para el disparo, solo para el estado de power-up
                this.currentFireRate = this.baseFireRate;
                this.isMultiShot = false; // Power-up permanente
                this.tempSpeedBoostEndTime = 0;
                this.tempFireRateBoostEndTime = 0;
                this.color = '#00ffff'; // Cían
                this.isAlive = true;
                this.invulnerabilityTime = 0;
                this.canShoot = true; // Controlar cadencia de disparo al hacer click
                this.shotCooldown = 8; // Cooldown de frames entre disparos (para el click)
            }

            update() {
                if (!this.isAlive) return;

                // --- Manejar Power-ups Temporales ---
                const currentTime = Date.now();
                this.currentSpeed = this.baseSpeed;
                
                if (currentTime < this.tempSpeedBoostEndTime) {
                    this.currentSpeed = this.baseSpeed * 2.5; // Aumento de velocidad
                }
                
                // Si el jugador está invulnerable, disminuir el tiempo de invulnerabilidad
                if (currentTime < this.invulnerabilityTime) {
                    this.color = (gameFrame % 10 < 5) ? '#ffffff' : '#00ffff'; // Efecto de parpadeo
                } else {
                    this.color = '#00ffff';
                }
                
                // --- Movimiento y límites ---
                let dx = mouseX - this.x;
                let dy = mouseY - this.y;
                
                this.x += Math.min(Math.abs(dx), this.currentSpeed) * Math.sign(dx);
                this.y += Math.min(Math.abs(dy), this.currentSpeed) * Math.sign(dy);

                // Asegurar que la nave permanezca dentro de los límites
                this.x = Math.max(this.width / 2, Math.min(CANVAS_WIDTH - this.width / 2, this.x));
                this.y = Math.max(this.height / 2, Math.min(CANVAS_HEIGHT - this.height / 2, this.y));

                // Manejar el cooldown de disparo (solo si hay powerup activo)
                if (currentTime < this.tempFireRateBoostEndTime) {
                     this.shotCooldown = 4; // Mayor cadencia temporal (más rápido)
                } else {
                     this.shotCooldown = 8; // Cadencia normal
                }
            }

            // Llamado por el evento de click
            triggerShot() {
                if (!this.canShoot || !this.isAlive) return;

                this.shoot();
                this.canShoot = false;
                
                // Usamos el gameFrame para controlar el cooldown de disparo
                const currentFrame = gameFrame;
                
                // Establece un timeout basado en el número de frames
                const checkCooldown = () => {
                    if (gameFrame >= currentFrame + this.shotCooldown) {
                        this.canShoot = true;
                    } else {
                        requestAnimationFrame(checkCooldown);
                    }
                };
                requestAnimationFrame(checkCooldown);
            }
            
            shoot() {
                if (this.isMultiShot) {
                    // Triple disparo en arco (-30, 0, 30 grados)
                    const angleRad = Math.PI / 180;
                    const speed = 6;
                    
                    const angles = [angleRad * -30, angleRad * 0, angleRad * 30];
                    
                    angles.forEach(angle => {
                        const vx = Math.sin(angle) * speed;
                        const vy = -Math.cos(angle) * speed;
                        const projectile = new Projectile(this.x, this.y - this.height / 2, vx, vy, '#00ff00', true);
                        playerProjectiles.push(projectile);
                    });
                } else {
                    // Disparo simple
                    const projectile = new Projectile(this.x, this.y - this.height / 2, 0, -6, '#00ff00', true);
                    playerProjectiles.push(projectile);
                }
            }

            draw() {
                if (!this.isAlive) return;
                ctx.fillStyle = this.color;
                
                // Dibujar nave como un pequeño triángulo retro
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.height / 2); // Punta superior
                ctx.lineTo(this.x - this.width / 2, this.y + this.height / 2); // Esquina inferior izquierda
                ctx.lineTo(this.x + this.width / 2, this.y + this.height / 2); // Esquina inferior derecha
                ctx.closePath();
                ctx.fill();

                // Detalle central para un look más "retro"
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
            }

            hit() {
                if (Date.now() < this.invulnerabilityTime) return; // Si es invulnerable, ignorar el golpe

                lives--;
                if (lives <= 0) {
                    this.isAlive = false;
                    isGameOver = true;
                } else {
                    // Invulnerabilidad temporal después de ser golpeado (e.g., 2 segundos)
                    this.invulnerabilityTime = Date.now() + 2000; 
                }
            }

            applyPowerUp(type) {
                const duration = 30000; // 30 segundos
                const currentTime = Date.now();
                
                switch(type) {
                    case 'speed':
                        this.tempSpeedBoostEndTime = currentTime + duration;
                        break;
                    case 'fireRate':
                        this.tempFireRateBoostEndTime = currentTime + duration; 
                        // La cadencia se maneja en el update() y triggerShot()
                        break;
                    case 'multiShot':
                        this.isMultiShot = true; // Efecto permanente
                        break;
                }
            }
        }

        // Clase Base para Enemigos (Normales)
        class Enemy {
            constructor(x, y, formation) {
                this.x = x;
                this.y = y;
                this.width = ENEMY_SIZE;
                this.height = ENEMY_SIZE;
                this.vy = 0; // Movimiento vertical es controlado por la formación
                this.vx = 0; // Movimiento horizontal es controlado por la formación
                this.formation = formation; // Referencia a la formación
                this.color = '#ff00ff'; // Magenta
                this.isAlive = true;
                this.fireRate = randomInt(100, 200); // Cadencia de disparo
                this.value = 10;
                this.isBoss = false;
            }

            update() {
                if (!this.isAlive) return;

                // La posición es relativa a la formación
                this.x = this.formation.x + this.relativeX;
                this.y = this.formation.y + this.relativeY;

                // Disparar si es el momento
                if (gameFrame % this.fireRate === 0 && player.isAlive) {
                    this.shoot();
                }
            }
            
            shoot() {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const speed = 3;
                
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                const projectile = new Projectile(this.x, this.y + this.height / 2, vx, vy, '#ff0000');
                enemyProjectiles.push(projectile);
            }

            draw() {
                if (!this.isAlive) return;

                ctx.fillStyle = this.color;
                
                // Dibujar enemigo como un cuadrado/diamante retro
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(Math.PI / 4); 
                ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                ctx.restore();
            }

            hit() {
                this.isAlive = false;
                // Notificar a la formación que un miembro fue destruido
                this.formation.enemyDestroyed(); 
                return this.value; // Devuelve la puntuación
            }
            
            // Método para chequear colisión (requerido para handleCollisions)
             checkCollision(other) {
                return checkCollision({
                    x: this.x, y: this.y, 
                    width: this.width, height: this.height
                }, other);
            }
        }

        // Nueva Clase: Formación de Enemigos (Controla el movimiento del grupo)
        class EnemyFormation {
            constructor(groupSize) {
                this.x = CANVAS_WIDTH / 2;
                this.y = -ENEMY_SIZE * 2;
                this.vx = 1.5; // Velocidad de movimiento lateral
                this.verticalDrop = 20; // Cuánto baja en cada ciclo
                this.isAlive = true;
                this.enemies = [];
                this.initialOffset = (groupSize - 1) * ENEMY_SIZE * 1.5 / 2;
                
                for (let i = 0; i < groupSize; i++) {
                    const enemy = new Enemy(0, 0, this);
                    enemy.relativeX = (i * ENEMY_SIZE * 1.5) - this.initialOffset; // Distribuir en X
                    enemy.relativeY = 0; // Sin offset vertical inicial
                    this.enemies.push(enemy);
                }
            }
            
            update() {
                if (!this.isAlive) return;
                
                this.x += this.vx;
                
                // Detección de borde lateral (se basa en el enemigo más a la derecha/izquierda)
                const rightmostEnemyX = this.x + this.initialOffset + ENEMY_SIZE / 2;
                const leftmostEnemyX = this.x - this.initialOffset - ENEMY_SIZE / 2;
                
                let drop = false;

                if (rightmostEnemyX > CANVAS_WIDTH) {
                    this.vx *= -1; // Cambiar dirección
                    this.x = CANVAS_WIDTH - this.initialOffset - ENEMY_SIZE / 2; // Ajustar posición
                    drop = true;
                } else if (leftmostEnemyX < 0) {
                    this.vx *= -1; // Cambiar dirección
                    this.x = this.initialOffset + ENEMY_SIZE / 2; // Ajustar posición
                    drop = true;
                }
                
                if (drop) {
                    this.y += this.verticalDrop; // Bajar una posición
                }

                // Actualizar a todos los enemigos dentro de la formación
                this.enemies.forEach(e => e.update());
                
                // Filtrar enemigos muertos
                this.enemies = this.enemies.filter(e => e.isAlive);
                
                // Si todos los enemigos han muerto, la formación ya no está viva
                if (this.enemies.length === 0) {
                    this.isAlive = false;
                }
            }

            draw() {
                // Dibujar a los enemigos individuales, ellos se encargan de su propio dibujo
                this.enemies.forEach(e => e.draw());
            }
            
            enemyDestroyed() {
                 // Si solo quedan enemigos muertos, la formación será eliminada en el próximo update.
            }
        }

        // Clase Mini-Jefe
        class MiniBoss extends Enemy {
            constructor() {
                // El jefe es un enemigo que no necesita formación, por eso se pasa 'null'
                super(CANVAS_WIDTH / 2, -BOSS_SIZE, null); 
                this.width = BOSS_SIZE;
                this.height = BOSS_SIZE;
                this.color = '#ffff00'; // Amarillo
                this.maxHp = 10;
                this.hp = this.maxHp;
                this.value = 100;
                this.vy = 0.5; // Velocidad de descenso
                this.fireRate = 50; 
                this.isBoss = true;
                this.vx = 1; // Movimiento lateral propio del jefe
            }
            
            update() {
                 if (!this.isAlive) return;
                
                this.y += this.vy;
                this.x += this.vx;

                // Rebotar en los bordes horizontales
                if (this.x < this.width / 2 || this.x > CANVAS_WIDTH - this.width / 2) {
                    this.vx *= -1;
                }

                // Disparar si es el momento
                if (gameFrame % this.fireRate === 0 && player.isAlive) {
                    this.shoot();
                }
            }


            // Implementación del disparo de 5 balas en arco
            shoot() {
                const speed = 4; // Velocidad de los proyectiles del jefe
                const numProjectiles = 5;
                const totalArc = Math.PI / 3; // Arco de 60 grados 
                
                // Calcular el ángulo central hacia el jugador
                const centralAngle = Math.atan2(player.y - this.y, player.x - this.x);

                for (let i = 0; i < numProjectiles; i++) {
                    // Calcular el desplazamiento angular: -2, -1, 0, 1, 2
                    const angleOffset = (i - Math.floor(numProjectiles / 2)) * (totalArc / (numProjectiles - 1));
                    const angle = centralAngle + angleOffset;

                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;

                    // Color distintivo para las balas del jefe
                    const projectile = new Projectile(this.x, this.y + this.height / 2, vx, vy, '#ff4500'); 
                    enemyProjectiles.push(projectile);
                }
            }

            draw() {
                // Dibujar el cuerpo del jefe (Un cuadrado grande)
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                
                // Dibujar ojos (detalle)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(this.x - 10, this.y - 5, 5, 5);
                ctx.fillRect(this.x + 5, this.y - 5, 5, 5);
                
                // Dibujar barra de vida
                const barWidth = 40;
                const barHeight = 4;
                const healthRatio = this.hp / this.maxHp;
                
                // Fondo de la barra de vida
                ctx.fillStyle = '#555555';
                ctx.fillRect(this.x - barWidth / 2, this.y + this.height / 2 + 5, barWidth, barHeight);
                
                // Vida actual
                ctx.fillStyle = healthRatio > 0.3 ? '#00ff00' : '#ff0000';
                ctx.fillRect(this.x - barWidth / 2, this.y + this.height / 2 + 5, barWidth * healthRatio, barHeight);
            }

            hit() {
                this.hp--;
                if (this.hp <= 0) {
                    this.isAlive = false;
                    return this.value;
                }
                return 0; // No suma puntos hasta que muere
            }
        }

        // Clase PowerUp
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 15;
                this.height = 15;
                this.type = type; // 'speed', 'fireRate', 'multiShot'
                this.vy = 1; // Desciende lentamente
                this.readyToDie = false;
                
                // Configurar color y símbolo
                if (type === 'speed') {
                    this.color = '#ffff00'; // Amarillo
                    this.symbol = 'S';
                } else if (type === 'fireRate') {
                    this.color = '#ff00ff'; // Magenta
                    this.symbol = 'F';
                } else { // multiShot
                    this.color = '#00ffff'; // Cían
                    this.symbol = 'M';
                }
            }

            update() {
                this.y += this.vy;
                if (this.y > CANVAS_HEIGHT) {
                    this.readyToDie = true;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                
                ctx.fillStyle = '#000000';
                ctx.font = '12px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(this.symbol, this.x, this.y + 4);
            }
        }


        // === FUNCIONES DE JUEGO ===

        function initGame() {
            // Reiniciar el estado
            score = 0;
            gameFrame = 0;
            lives = INITIAL_LIVES;
            isGameOver = false;
            formations = []; // Usar formaciones en lugar de enemigos directos
            miniBoss = null;
            powerUps = [];
            playerProjectiles = [];
            enemyProjectiles = [];
            
            // Crear el jugador
            player = new Player();
            
            resizeCanvas();
            
            if (typeof gameLoopId !== 'undefined') cancelAnimationFrame(gameLoopId);
            gameLoop();
        }

        function spawnFormation() {
            formations.push(new EnemyFormation(FORMATION_GROUP_SIZE));
        }
        
        function spawnBoss() {
            miniBoss = new MiniBoss();
        }
        
        function spawnRandomPowerUp(x, y) {
            const types = ['speed', 'fireRate', 'multiShot'];
            const type = types[randomInt(0, types.length - 1)];
            powerUps.push(new PowerUp(x, y, type));
        }

        function checkCollision(obj1, obj2) {
            // AABB Colisión
            return obj1.x - obj1.width / 2 < obj2.x + obj2.width / 2 &&
                   obj1.x + obj1.width / 2 > obj2.x - obj2.width / 2 &&
                   obj1.y - obj1.height / 2 < obj2.y + obj2.height / 2 &&
                   obj1.y + obj1.height / 2 > obj2.y - obj2.height / 2;
        }

        function handleCollisions() {
            // Recoger todos los enemigos individuales de las formaciones
            const allEnemies = formations.flatMap(f => f.enemies).concat(miniBoss && miniBoss.isAlive ? [miniBoss] : []);

            // 1. Proyectiles del jugador vs Enemigos y Jefe
            playerProjectiles.forEach(p => {
                allEnemies.forEach(e => {
                    if (!p.readyToDie && e.isAlive && e.checkCollision(p)) {
                        p.readyToDie = true;
                        score += e.hit();
                        
                        // 1 de cada 5 enemigos suelta un power-up
                        if (e.isBoss === false && !e.isAlive && randomInt(1, 5) === 1) {
                            spawnRandomPowerUp(e.x, e.y);
                        }
                    }
                });
            });

            // 2. Proyectiles enemigos vs Jugador
            enemyProjectiles.forEach(p => {
                if (player.isAlive && Date.now() >= player.invulnerabilityTime && !p.readyToDie && checkCollision(p, player)) {
                    p.readyToDie = true;
                    player.hit();
                }
            });

            // 3. Enemigos vs Jugador (Contacto directo)
            allEnemies.forEach(e => {
                if (player.isAlive && Date.now() >= player.invulnerabilityTime && e.isAlive && e.checkCollision(player)) {
                    e.isAlive = false;
                    player.hit();
                }
            });
            
            // 4. Power-ups vs Jugador
            powerUps.forEach(pu => {
                if (player.isAlive && checkCollision(pu, player)) {
                    pu.readyToDie = true;
                    player.applyPowerUp(pu.type);
                }
            });
        }

        function drawScore() {
            ctx.fillStyle = '#00ff00';
            ctx.font = '8px "Press Start 2P"';
            ctx.textAlign = 'left';
            ctx.fillText(`PUNTOS: ${score}`, 10, 20);
            
            ctx.textAlign = 'right';
            ctx.fillText(`VIDAS: ${lives}`, CANVAS_WIDTH - 10, 20);
            
            // Mostrar estado de Power-ups
            ctx.font = '6px "Press Start 2P"';
            ctx.textAlign = 'left';
            
            let puY = 35;
            if (player.isMultiShot) {
                ctx.fillStyle = '#00ffff';
                ctx.fillText(`MULTIDISPARO (M)`, 10, puY);
                puY += 10;
            }
            
            const currentTime = Date.now();
            if (currentTime < player.tempSpeedBoostEndTime) {
                ctx.fillStyle = '#ffff00';
                const remaining = Math.ceil((player.tempSpeedBoostEndTime - currentTime) / 1000);
                ctx.fillText(`VELOCIDAD (S): ${remaining}s`, 10, puY);
                puY += 10;
            }
            if (currentTime < player.tempFireRateBoostEndTime) {
                ctx.fillStyle = '#ff00ff';
                const remaining = Math.ceil((player.tempFireRateBoostEndTime - currentTime) / 1000);
                ctx.fillText(`CADENCIA (F): ${remaining}s`, 10, puY);
            }
        }

        function drawGameOver() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.fillStyle = '#ff0000';
            ctx.textAlign = 'center';
            ctx.font = '30px "Press Start 2P"';
            ctx.fillText('FIN DEL JUEGO', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 30);
            
            ctx.fillStyle = '#00ffff';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText(`PUNTUACIÓN FINAL: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 10);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText('CLIC PARA REINICIAR', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 50);
        }

        // === CICLO PRINCIPAL DEL JUEGO ===
        function gameLoop() {
            // 1. Limpiar el canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (!isGameOver) {
                // 2. Lógica de Spawning (aparición de formaciones y jefe)
                if (miniBoss === null && score >= 50) {
                    spawnBoss();
                } else if (miniBoss === null || !miniBoss.isAlive) {
                    if (gameFrame % ENEMY_SPAWN_RATE === 0) {
                        spawnFormation();
                    }
                }

                // 3. Actualizar entidades
                player.update();
                formations.forEach(f => f.update());
                if (miniBoss && miniBoss.isAlive) miniBoss.update();
                powerUps.forEach(pu => pu.update());
                playerProjectiles.forEach(p => p.update());
                enemyProjectiles.forEach(p => p.update());

                // 4. Detección y manejo de colisiones
                handleCollisions();

                // 5. Filtrar (eliminar) entidades
                // Eliminar formaciones que ya no están vivas o están fuera de la pantalla
                formations = formations.filter(f => f.isAlive && f.y < CANVAS_HEIGHT); 
                powerUps = powerUps.filter(pu => !pu.readyToDie);
                playerProjectiles = playerProjectiles.filter(p => !p.readyToDie);
                enemyProjectiles = enemyProjectiles.filter(p => !p.readyToDie);
                
                // Si el jefe murió, reiniciar la variable
                if (miniBoss && !miniBoss.isAlive) miniBoss = null;

                // 6. Dibujar entidades
                formations.forEach(f => f.draw());
                if (miniBoss && miniBoss.isAlive) miniBoss.draw();
                powerUps.forEach(pu => pu.draw());
                playerProjectiles.forEach(p => p.draw());
                enemyProjectiles.forEach(p => p.draw());
                player.draw();

                // 7. Dibujar Interfaz
                drawScore();

                gameFrame++;
            } else {
                // Estado de Game Over
                drawGameOver();
            }

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // === MANEJO DE EVENTOS ===

        // Rastrea la posición del mouse
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            // Calcular posición relativa al canvas
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;
        });
        
        // Manejar el clic para disparar y reiniciar el juego
        canvas.addEventListener('click', (e) => {
            if (isGameOver) {
                initGame();
            } else {
                 player.triggerShot(); // Disparo solo con click
            }
        });
        
        // Evitar el menú contextual del click derecho
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });


        // Asegurar que el canvas se adapte al contenedor manteniendo la proporción
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            // Asegurar que el canvas use el espacio disponible en el contenedor
            const aspectRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
            let targetWidth = containerWidth;
            let targetHeight = containerWidth / aspectRatio;

            if (targetHeight > containerHeight) {
                targetHeight = containerHeight;
                targetWidth = containerHeight * aspectRatio;
            }

            canvas.style.width = `${targetWidth}px`;
            canvas.style.height = `${targetHeight}px`;
        }
        
        // Ejecutar resize en carga y cambio de tamaño de ventana
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', () => {
            resizeCanvas();
            drawGameOver(); // Mostrar la pantalla de inicio
        });

        setTimeout(resizeCanvas, 0);
    </script>
</body>
</html>