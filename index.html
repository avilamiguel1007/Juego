<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Galaga - Clon Arcade</title>
    <!-- Carga de Tailwind CSS para estilizado -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Estilos personalizados para el ambiente retro */
        body {
            background-color: #0d1117; /* Fondo oscuro casi negro */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: 'Press Start 2P', cursive;
        }

        #game-container {
            border: 4px solid #00ff00; /* Borde verde brillante */
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.7);
            background-color: #1a1a2e; /* Fondo del juego ligeramente diferente */
            position: relative;
            overflow: hidden;
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            background-color: #000000;
            display: block;
        }

        .text-retro {
            color: #00ff00; /* Texto verde brillante */
            text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
            line-height: 1.2;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="game-container" class="w-full max-w-lg aspect-[3/4]">
        <canvas id="gameCanvas"></canvas>
    </div>

    <script>
        // === CONFIGURACIÓN GLOBAL ===
        const CANVAS_WIDTH = 400;
        const CANVAS_HEIGHT = 600;
        const PLAYER_SIZE = 20;
        const ENEMY_SIZE = 16;
        const BOSS_SIZE = 32;
        const PROJECTILE_WIDTH = 3;
        const PROJECTILE_HEIGHT = 8;
        const ENEMY_SPAWN_RATE = 200; // Frames entre aparición de formaciones
        const INITIAL_LIVES = 3;
        const MAX_LIVES = 5; // Nuevo límite máximo de vidas
        const FORMATION_GROUP_SIZE = 3; 

        // === INICIALIZACIÓN ===
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Ajustar el canvas al contenedor
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // Variables de estado del juego
        let gameFrame = 0;
        let score = 0;
        let lives = INITIAL_LIVES;
        let isGameOver = true;
        let player = null;
        let formations = []; 
        let powerUps = []; 
        let playerProjectiles = [];
        let enemyProjectiles = [];
        let mouseX = CANVAS_WIDTH / 2;
        let mouseY = CANVAS_HEIGHT / 2; 
        let gameLoopId;
        
        let highscore = parseInt(localStorage.getItem('highscore')) || 0; // Cargar el récord
        
        // El minijefe ahora es una formación de 3 minijefes
        let miniBossFormations = []; 

        // Función de utilidad para obtener un número aleatorio entre min y max (inclusive)
        function randomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // === CLASES DE ENTIDADES ===

        // Clase Base para Proyectiles
        class Projectile {
            constructor(x, y, vx, vy, color, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.width = PROJECTILE_WIDTH;
                this.height = PROJECTILE_HEIGHT;
                this.color = color;
                this.isPlayer = isPlayer;
                this.readyToDie = false;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                // Marcar para eliminación si está fuera de pantalla
                if (this.y < -this.height || this.y > CANVAS_HEIGHT + this.height || this.x < 0 || this.x > CANVAS_WIDTH) {
                    this.readyToDie = true;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            }
        }

        // Clase Nave del Jugador
        class Player {
            constructor() {
                this.x = CANVAS_WIDTH / 2;
                this.y = CANVAS_HEIGHT - 50;
                this.width = PLAYER_SIZE;
                this.height = PLAYER_SIZE;
                this.baseSpeed = 4;
                this.currentSpeed = this.baseSpeed;
                this.isMultiShot = false; 
                this.tempShieldEndTime = 0; // Nuevo para el escudo
                this.color = '#00ffff'; 
                this.isAlive = true;
                this.invulnerabilityTime = 0;
                this.canShoot = true; 
                this.shotCooldown = 8; 
                
                this.minions = []; // Minions del jugador
                this.maxMinions = 3;
            }

            isInvulnerable() {
                const currentTime = Date.now();
                // Invulnerabilidad por golpe O Escudo de Power-up
                return currentTime < this.invulnerabilityTime || currentTime < this.tempShieldEndTime;
            }

            update() {
                if (!this.isAlive) return;

                const currentTime = Date.now();
                this.currentSpeed = this.baseSpeed; // Velocidad base (sin item de velocidad)
                
                // Efecto visual y lógica de invulnerabilidad/escudo
                if (this.isInvulnerable()) {
                    // Si el escudo está activo, color amarillo sólido
                    if (currentTime < this.tempShieldEndTime) {
                        this.color = '#ffff00'; 
                    } else {
                        // Si es invulnerabilidad por golpe, parpadeo cian/blanco
                        this.color = (gameFrame % 10 < 5) ? '#ffffff' : '#00ffff'; 
                    }
                } else {
                    this.color = '#00ffff';
                }
                
                // --- Movimiento y límites ---
                let dx = mouseX - this.x;
                let dy = mouseY - this.y;
                
                this.x += Math.min(Math.abs(dx), this.currentSpeed) * Math.sign(dx);
                this.y += Math.min(Math.abs(dy), this.currentSpeed) * Math.sign(dy);

                this.x = Math.max(this.width / 2, Math.min(CANVAS_WIDTH - this.width / 2, this.x));
                this.y = Math.max(this.height / 2, Math.min(CANVAS_HEIGHT - this.height / 2, this.y));

                // Manejar el cooldown de disparo 
                this.shotCooldown = 8; 
                
                // Actualizar Minions
                this.minions.forEach(m => m.update());
                // Limpiar minions expirados
                this.minions = this.minions.filter(m => m.isAlive);
            }

            triggerShot() {
                if (!this.canShoot || !this.isAlive) return;

                this.shoot();
                this.canShoot = false;
                
                const currentFrame = gameFrame;
                
                const checkCooldown = () => {
                    if (gameFrame >= currentFrame + this.shotCooldown) {
                        this.canShoot = true;
                    } else {
                        requestAnimationFrame(checkCooldown);
                    }
                };
                requestAnimationFrame(checkCooldown);
            }
            
            shoot() {
                if (this.isMultiShot) {
                    const angleRad = Math.PI / 180;
                    const speed = 6;
                    const angles = [angleRad * -30, angleRad * 0, angleRad * 30];
                    
                    angles.forEach(angle => {
                        const vx = Math.sin(angle) * speed;
                        const vy = -Math.cos(angle) * speed;
                        const projectile = new Projectile(this.x, this.y - this.height / 2, vx, vy, '#00ff00', true);
                        playerProjectiles.push(projectile);
                    });
                } else {
                    const projectile = new Projectile(this.x, this.y - this.height / 2, 0, -6, '#00ff00', true);
                    playerProjectiles.push(projectile);
                }
            }

            draw() {
                if (!this.isAlive) return;
                
                // Dibujar Minions primero para que estén "detrás" o a los lados del jugador
                this.minions.forEach(m => m.draw());
                
                ctx.fillStyle = this.color;
                
                // Dibujar nave
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.height / 2); 
                ctx.lineTo(this.x - this.width / 2, this.y + this.height / 2); 
                ctx.lineTo(this.x + this.width / 2, this.y + this.height / 2); 
                ctx.closePath();
                ctx.fill();

                // Detalle central
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(this.x - 2, this.y - 2, 4, 4);
                
                // Dibujar el escudo visualmente si está activo
                if (Date.now() < this.tempShieldEndTime) {
                    ctx.strokeStyle = '#ffff00';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.width * 1.5, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }

            hit() {
                if (this.isInvulnerable()) return; 

                lives--;
                if (lives <= 0) {
                    this.isAlive = false;
                    isGameOver = true;
                } else {
                    // 2 segundos de invulnerabilidad después de ser golpeado
                    this.invulnerabilityTime = Date.now() + 2000; 
                }
            }

            applyPowerUp(type) {
                const currentTime = Date.now();
                
                switch(type) {
                    case 'multiShot':
                        this.isMultiShot = true; 
                        break;
                    case 'life': // Power-up de Vida
                        if (lives < MAX_LIVES) {
                            lives = Math.min(lives + 1, MAX_LIVES);
                        } else {
                            // Si ya tiene el máximo, aplica el escudo temporal (10s)
                            this.tempShieldEndTime = currentTime + 10000; // REDUCIDO A 10s
                        }
                        break;
                    case 'minion': // Nuevo Power-up de Minion
                        if (this.minions.length < this.maxMinions) {
                            this.addMinion();
                        } else {
                             // Si ya tiene el máximo de minions, aplica el escudo temporal (10s)
                            this.tempShieldEndTime = currentTime + 10000; // REDUCIDO A 10s
                        }
                        break;
                }
            }
            
            addMinion() {
                const minionDuration = 10000; // REDUCIDO A 10 segundos
                const endTime = Date.now() + minionDuration;
                
                // positionIndex: 0 (Norte), 1 (Este), 2 (Oeste)
                const positionIndex = this.minions.length; 
                
                if (positionIndex < this.maxMinions) {
                    // Reiniciar la duración de todos los minions existentes
                    this.minions.forEach(m => m.endTime = endTime);
                    this.minions.push(new Minion(this, positionIndex, endTime));
                }
            }
        }

        // Clase Nave Minion (Mascota)
        class Minion {
            constructor(player, positionIndex, endTime) {
                this.player = player;
                this.positionIndex = positionIndex; // 0: N, 1: E, 2: W
                this.endTime = endTime;
                this.isAlive = true;
                this.size = 12; 
                this.color = '#ff8c00'; // Naranja
                this.fireRate = 40; 
                this.offsetDistance = 25; // Distancia del jugador
                
                this.x = 0;
                this.y = 0;
            }
            
            update() {
                if (Date.now() > this.endTime) {
                    this.isAlive = false;
                    return;
                }

                // Definir offsets basados en la posición cardinal
                let offsetX = 0;
                let offsetY = 0;
                
                switch (this.positionIndex) {
                    case 0: // Norte
                        offsetX = 0;
                        offsetY = -this.offsetDistance;
                        break;
                    case 1: // Este (Derecha)
                        offsetX = this.offsetDistance;
                        offsetY = 0;
                        break;
                    case 2: // Oeste (Izquierda)
                        offsetX = -this.offsetDistance;
                        offsetY = 0;
                        break;
                }
                
                this.x = this.player.x + offsetX;
                this.y = this.player.y + offsetY;
                
                // Disparo automático
                if (gameFrame % this.fireRate === 0 && this.player.isAlive) {
                    this.shoot();
                }
            }
            
            shoot() {
                const speed = 6;
                const minionColor = this.color;

                // El minion hereda el Power-Up de multidisparo del jugador
                if (this.player.isMultiShot) {
                    // 3-way shot like the player
                    const angleRad = Math.PI / 180;
                    const angles = [angleRad * -30, angleRad * 0, angleRad * 30];
                    
                    angles.forEach(angle => {
                        const vx = Math.sin(angle) * speed;
                        const vy = -Math.cos(angle) * speed;
                        const projectile = new Projectile(this.x, this.y - this.size / 2, vx, vy, minionColor, true);
                        playerProjectiles.push(projectile);
                    });
                } else {
                    // Disparo simple vertical hacia arriba
                    const projectile = new Projectile(this.x, this.y - this.size / 2, 0, -6, minionColor, true);
                    playerProjectiles.push(projectile);
                }
            }
            
            draw() {
                if (!this.isAlive) return;

                ctx.fillStyle = this.color;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                // Dibujar un rombo para el minion
                ctx.rotate(Math.PI / 4); 
                ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
                
                // Indicador de vida restante
                const remainingTime = this.endTime - Date.now();
                if (remainingTime < 3000 && gameFrame % 10 < 5) { // Advertencia a los 3 segundos
                     ctx.fillStyle = '#ff0000'; // Rojo si está a punto de expirar
                } else {
                     ctx.fillStyle = '#ffffff';
                }
                ctx.fillRect(-2, -2, 4, 4);
                
                ctx.restore();
            }
        }


        // Clase Base para Enemigos (Normales)
        class Enemy {
            constructor(x, y, formation, isBoss = false) {
                this.x = x;
                this.y = y;
                this.width = isBoss ? BOSS_SIZE : ENEMY_SIZE;
                this.height = isBoss ? BOSS_SIZE : ENEMY_SIZE;
                this.formation = formation; 
                this.isBoss = isBoss;
                this.color = isBoss ? '#ffff00' : '#ff00ff';
                this.isAlive = true;
                this.fireRate = isBoss ? 50 : randomInt(100, 200); 
                this.value = isBoss ? 100 : 10;
                this.maxHp = isBoss ? 10 : 1;
                this.hp = this.maxHp;
            }

            update() {
                if (!this.isAlive) return;

                // La posición es relativa a la formación
                this.x = this.formation.x + this.relativeX;
                this.y = this.formation.y + this.relativeY;

                // Disparar solo si el enemigo está visible en la pantalla
                // La formación maneja el movimiento, así que verificamos la posición 'y' de la formación
                if (this.formation.y > -this.height / 2 && gameFrame % this.fireRate === 0 && player.isAlive) {
                    this.shoot();
                }
            }
            
            shoot() {
                if (this.isBoss) {
                    this.bossShoot();
                    return;
                }
                
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                const speed = 3;
                
                const vx = Math.cos(angle) * speed;
                const vy = Math.sin(angle) * speed;

                const projectile = new Projectile(this.x, this.y + this.height / 2, vx, vy, '#ff0000');
                enemyProjectiles.push(projectile);
            }
            
            // Disparo especial del Minijefe
            bossShoot() {
                const speed = 4; 
                const numProjectiles = 5;
                const totalArc = Math.PI / 3; 
                
                const centralAngle = Math.atan2(player.y - this.y, player.x - this.x);

                for (let i = 0; i < numProjectiles; i++) {
                    const angleOffset = (i - Math.floor(numProjectiles / 2)) * (totalArc / (numProjectiles - 1));
                    const angle = centralAngle + angleOffset;

                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;

                    const projectile = new Projectile(this.x, this.y + this.height / 2, vx, vy, '#ff4500'); 
                    enemyProjectiles.push(projectile);
                }
            }

            draw() {
                if (!this.isAlive) return;

                ctx.fillStyle = this.color;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                if (this.isBoss) {
                    // Dibujar el cuerpo del jefe
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                    
                    // Dibujar barra de vida
                    const barWidth = 40;
                    const barHeight = 4;
                    const healthRatio = this.hp / this.maxHp;
                    
                    ctx.fillStyle = '#555555';
                    ctx.fillRect(-barWidth / 2, this.height / 2 + 5, barWidth, barHeight);
                    
                    ctx.fillStyle = healthRatio > 0.3 ? '#00ff00' : '#ff0000';
                    ctx.fillRect(-barWidth / 2, this.height / 2 + 5, barWidth * healthRatio, barHeight);

                } else {
                    // Dibujar enemigo normal
                    ctx.rotate(Math.PI / 4); 
                    ctx.fillRect(-this.width / 2, -this.height / 2, this.width, this.height);
                }
                ctx.restore();
            }

            hit() {
                this.hp--;
                if (this.hp <= 0) {
                    this.isAlive = false;
                    // Notificar a la formación que un miembro fue destruido
                    this.formation.enemyDestroyed(); 
                    return this.value; 
                }
                return 0; // No suma puntos hasta que muere (excepto el jefe que tiene HP)
            }
            
             checkCollision(other) {
                return checkCollision({
                    x: this.x, y: this.y, 
                    width: this.width, height: this.height
                }, other);
            }
        }

        // Clase: Formación de Enemigos (Controla el movimiento del grupo)
        class EnemyFormation {
            constructor(groupSize, isBossFormation = false) {
                this.x = CANVAS_WIDTH / 2;
                this.y = -BOSS_SIZE * 2; // Iniciar arriba
                this.vx = isBossFormation ? 1.0 : 1.5; 
                this.verticalDrop = isBossFormation ? 30 : 20; 
                this.isAlive = true;
                this.enemies = [];
                this.isBossFormation = isBossFormation;
                
                // Distancia entre enemigos
                const separation = isBossFormation ? BOSS_SIZE * 1.5 : ENEMY_SIZE * 1.5;
                this.initialOffset = (groupSize - 1) * separation / 2;
                
                for (let i = 0; i < groupSize; i++) {
                    const enemy = new Enemy(0, 0, this, isBossFormation);
                    enemy.relativeX = (i * separation) - this.initialOffset; 
                    enemy.relativeY = 0; 
                    this.enemies.push(enemy);
                }
            }
            
            update() {
                if (!this.isAlive) return;
                
                this.x += this.vx;
                
                const enemySize = this.isBossFormation ? BOSS_SIZE : ENEMY_SIZE;
                const rightmostEnemyX = this.x + this.initialOffset + enemySize / 2;
                const leftmostEnemyX = this.x - this.initialOffset - enemySize / 2;
                
                let drop = false;

                if (rightmostEnemyX > CANVAS_WIDTH) {
                    this.vx *= -1; 
                    this.x = CANVAS_WIDTH - this.initialOffset - enemySize / 2; 
                    drop = true;
                } else if (leftmostEnemyX < 0) {
                    this.vx *= -1; 
                    this.x = this.initialOffset + enemySize / 2; 
                    drop = true;
                }
                
                if (drop) {
                    this.y += this.verticalDrop; 
                }

                this.enemies.forEach(e => e.update());
                this.enemies = this.enemies.filter(e => e.isAlive);
                
                if (this.enemies.length === 0) {
                    this.isAlive = false;
                }
            }

            draw() {
                this.enemies.forEach(e => e.draw());
            }
            
            enemyDestroyed() {
                 // La lógica de eliminación se maneja en el update()
            }
        }

        // Clase PowerUp
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 15;
                this.height = 15;
                this.type = type; // 'minion', 'multiShot', 'life'
                this.vy = 1; 
                this.readyToDie = false;
                
                if (type === 'minion') {
                    this.color = '#ff8c00'; // Naranja para minion
                    this.symbol = 'M';
                } else if (type === 'multiShot') {
                    this.color = '#00ffff'; 
                    this.symbol = 'W'; // W for Wide shot (disparo amplio)
                } else { // life
                    this.color = '#00ff00'; 
                    this.symbol = '+1';
                }
            }

            update() {
                this.y += this.vy;
                if (this.y > CANVAS_HEIGHT) {
                    this.readyToDie = true;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                
                ctx.fillStyle = '#000000';
                ctx.font = '10px "Press Start 2P"';
                ctx.textAlign = 'center';
                ctx.fillText(this.symbol, this.x, this.y + 4);
            }
        }


        // === FUNCIONES DE JUEGO ===

        function initGame() {
            // Guardar el récord al final de la partida anterior
            if (score > highscore) {
                highscore = score;
                localStorage.setItem('highscore', highscore);
            }
            
            // Reiniciar el estado
            score = 0;
            gameFrame = 0;
            lives = INITIAL_LIVES;
            isGameOver = false;
            formations = []; 
            miniBossFormations = [];
            powerUps = [];
            playerProjectiles = [];
            enemyProjectiles = [];
            
            // Crear el jugador
            player = new Player();
            
            resizeCanvas();
            
            if (typeof gameLoopId !== 'undefined') cancelAnimationFrame(gameLoopId);
            gameLoop();
        }

        function spawnFormation() {
            // Siempre aparece una formación normal
            formations.push(new EnemyFormation(FORMATION_GROUP_SIZE, false)); 
            
            // 10% de probabilidad de que aparezca una formación de minijefes
            if (Math.random() < 0.1) { 
                miniBossFormations.push(new EnemyFormation(FORMATION_GROUP_SIZE, true));
            }
        }
        
        function spawnRandomPowerUp(x, y) {
            // 20% de probabilidad de drop en total
            if (Math.random() < 0.8) return; 
            
            let types = ['minion', 'multiShot', 'life']; // 'speed' eliminado, 'fireRate' renombrado a 'minion'
            
            const typeIndex = randomInt(0, types.length - 1);
            const type = types[typeIndex];
            
            powerUps.push(new PowerUp(x, y, type));
        }

        function checkCollision(obj1, obj2) {
            // AABB Colisión
            return obj1.x - obj1.width / 2 < obj2.x + obj2.width / 2 &&
                   obj1.x + obj1.width / 2 > obj2.x - obj2.width / 2 &&
                   obj1.y - obj1.height / 2 < obj2.y + obj2.height / 2 &&
                   obj1.y + obj1.height / 2 > obj2.y - obj2.height / 2;
        }

        function handleCollisions() {
            // Recoger todos los enemigos individuales de todas las formaciones
            const allEnemies = formations.flatMap(f => f.enemies).concat(miniBossFormations.flatMap(f => f.enemies));

            // 1. Proyectiles del jugador vs Enemigos
            playerProjectiles.forEach(p => {
                allEnemies.forEach(e => {
                    if (!p.readyToDie && e.isAlive && e.checkCollision(p)) {
                        p.readyToDie = true;
                        const scoreIncrease = e.hit();
                        score += scoreIncrease;
                        
                        // Si un enemigo/jefe muere, hay chance de soltar power-up
                        if (!e.isAlive && scoreIncrease > 0) {
                            // Se llama sin el parámetro isBoss, ya que el drop rate es fijo (20%)
                            spawnRandomPowerUp(e.x, e.y);
                        }
                    }
                });
            });

            // 2. Proyectiles enemigos vs Jugador
            enemyProjectiles.forEach(p => {
                if (player.isAlive && !player.isInvulnerable() && !p.readyToDie && checkCollision(p, player)) {
                    p.readyToDie = true;
                    player.hit();
                }
            });

            // 3. Enemigos vs Jugador (Contacto directo)
            allEnemies.forEach(e => {
                if (player.isAlive && !player.isInvulnerable() && e.isAlive && e.checkCollision(player)) {
                    // El enemigo es destruido por la colisión
                    e.isAlive = false;
                    // La formación será notificada y limpiada en el siguiente update
                    e.formation.enemyDestroyed(); 
                    player.hit();
                }
            });
            
            // 4. Power-ups vs Jugador
            powerUps.forEach(pu => {
                if (player.isAlive && checkCollision(pu, player)) {
                    pu.readyToDie = true;
                    player.applyPowerUp(pu.type);
                }
            });
        }

        function drawScore() {
            ctx.fillStyle = '#00ff00';
            ctx.font = '8px "Press Start 2P"';
            ctx.textAlign = 'left';
            ctx.fillText(`PUNTOS: ${score}`, 10, 20);
            
            ctx.textAlign = 'right';
            ctx.fillText(`VIDAS: ${lives}`, CANVAS_WIDTH - 10, 20);
            
            // Marcador de último récord
            ctx.fillStyle = '#ffff00';
            ctx.textAlign = 'center';
            ctx.fillText(`RECORD: ${highscore}`, CANVAS_WIDTH / 2, 20);

            // Mostrar estado de Power-ups
            ctx.font = '6px "Press Start 2P"';
            ctx.textAlign = 'left';
            
            let puY = 35;
            
            const currentTime = Date.now();

            if (currentTime < player.tempShieldEndTime) {
                ctx.fillStyle = '#ffff00';
                const remaining = Math.ceil((player.tempShieldEndTime - currentTime) / 1000);
                ctx.fillText(`ESCUDO: ${remaining}s`, 10, puY);
                puY += 10;
            } else if (player.isInvulnerable() && currentTime < player.invulnerabilityTime) {
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`INVULNERABLE`, 10, puY);
                puY += 10;
            }
            
            if (player.isMultiShot) {
                ctx.fillStyle = '#00ffff';
                ctx.fillText(`MULTIDISPARO (W)`, 10, puY);
                puY += 10;
            }
            
            // Estado de Minions (reemplaza a Velocidad y Cadencia)
            if (player.minions.length > 0) {
                ctx.fillStyle = '#ff8c00';
                const firstMinion = player.minions[0];
                const remaining = Math.ceil((firstMinion.endTime - currentTime) / 1000);
                ctx.fillText(`MINIONS: ${player.minions.length} (${remaining}s)`, 10, puY);
            }
        }

        function drawGameOver() {
            // Asegurarse de actualizar el highscore antes de dibujar
            if (score > highscore) {
                highscore = score;
                localStorage.setItem('highscore', highscore);
            }

            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.fillStyle = '#ff0000';
            ctx.textAlign = 'center';
            ctx.font = '30px "Press Start 2P"';
            ctx.fillText('FIN DEL JUEGO', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 - 40);
            
            ctx.fillStyle = '#00ffff';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText(`PUNTUACIÓN FINAL: ${score}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 0);
            
            ctx.fillStyle = '#ffff00';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText(`RÉCORD MÁXIMO: ${highscore}`, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 20);

            ctx.fillStyle = '#00ff00';
            ctx.font = '10px "Press Start 2P"';
            ctx.fillText('CLIC PARA REINICIAR', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 60);
        }

        // === CICLO PRINCIPAL DEL JUEGO ===
        function gameLoop() {
            // 1. Limpiar el canvas
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            if (!isGameOver) {
                // 2. Lógica de Spawning (aparición de formaciones y jefe)
                if (gameFrame % ENEMY_SPAWN_RATE === 0) {
                    spawnFormation();
                }

                // 3. Actualizar entidades
                player.update();
                formations.forEach(f => f.update());
                miniBossFormations.forEach(f => f.update());
                powerUps.forEach(pu => pu.update());
                playerProjectiles.forEach(p => p.update());
                enemyProjectiles.forEach(p => p.update());

                // 4. Detección y manejo de colisiones
                handleCollisions();

                // 5. Filtrar (eliminar) entidades
                formations = formations.filter(f => f.isAlive && f.y < CANVAS_HEIGHT + 100); 
                miniBossFormations = miniBossFormations.filter(f => f.isAlive && f.y < CANVAS_HEIGHT + 100);
                powerUps = powerUps.filter(pu => !pu.readyToDie);
                playerProjectiles = playerProjectiles.filter(p => !p.readyToDie);
                enemyProjectiles = enemyProjectiles.filter(p => !p.readyToDie);
                
                // 6. Dibujar entidades
                formations.forEach(f => f.draw());
                miniBossFormations.forEach(f => f.draw());
                powerUps.forEach(pu => pu.draw());
                playerProjectiles.forEach(p => p.draw());
                enemyProjectiles.forEach(p => p.draw());
                player.draw(); // El jugador dibuja a sus minions

                // 7. Dibujar Interfaz
                drawScore();

                gameFrame++;
            } else {
                // Estado de Game Over
                drawGameOver();
            }

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        // === MANEJO DE EVENTOS ===

        // Rastrea la posición del mouse
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            mouseX = (e.clientX - rect.left) * scaleX;
            mouseY = (e.clientY - rect.top) * scaleY;
        });
        
        // Manejar el clic para disparar y reiniciar el juego
        canvas.addEventListener('click', (e) => {
            if (isGameOver) {
                initGame();
            } else {
                 player.triggerShot(); // Disparo solo con click
            }
        });
        
        // Evitar el menú contextual del click derecho
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });


        // Asegurar que el canvas se adapte al contenedor manteniendo la proporción
        function resizeCanvas() {
            const container = document.getElementById('game-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const aspectRatio = CANVAS_WIDTH / CANVAS_HEIGHT;
            let targetWidth = containerWidth;
            let targetHeight = containerWidth / aspectRatio;

            if (targetHeight > containerHeight) {
                targetHeight = containerHeight;
                targetWidth = containerHeight * aspectRatio;
            }

            canvas.style.width = `${targetWidth}px`;
            canvas.style.height = `${targetHeight}px`;
        }
        
        // Ejecutar resize en carga y cambio de tamaño de ventana
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', () => {
            resizeCanvas();
            drawGameOver(); // Mostrar la pantalla de inicio
        });

        setTimeout(resizeCanvas, 0);
    </script>
</body>
</html>